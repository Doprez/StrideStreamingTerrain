namespace StrideTerrain.TerrainSystem.Effects
{
    shader TerrainNormalBlendComputeColor : ComputeColor, TerrainCommon, NormalStream, PositionStream4, Texturing
    {
        compose ComputeColor Sand;
        compose ComputeColor Rock;
        compose ComputeColor Grass;
        compose ComputeColor Snow;

        float InvLerp(float from, float to, float value){
            return (value - from) / (to - from);
        }

        float BlendHeight(float h, float b) {
            if (streams.TerrainHeight < (h - b)) return 0.0f;
            else if (streams.TerrainHeight > (h + b)) return 1.0f;
            return InvLerp(h - b, h + b, streams.TerrainHeight);
        }

        float BlendSlope(float s, float b) {
            float slope = 1.0f - abs(streams.meshNormal.y);
            if (slope < s - b) return 0.0f;
            else if (slope > s + b) return 1.0f;
            else return InvLerp(s - b, s + b, slope);
        }

        float3 SampleTerrain(float2 uv)
        {
            streams.TexCoord2 = uv;

            float blendRock = BlendSlope(0.1f, 0.1f);
            float blendSnow = BlendHeight(200, 60);
            float blendGrass = BlendHeight(79.0f, 2.0f);

            float3 sand = Sand.Compute();
            float3 grass = Grass.Compute();
            float3 snow = Snow.Compute();

            streams.TexCoord2 = uv * 0.1f;
            float3 rock = Rock.Compute();

            float3 output = NormalUtil.BlendPartialDerivative(sand, grass, blendGrass);
            output = NormalUtil.BlendPartialDerivative(output, snow, blendSnow);
            output = NormalUtil.BlendPartialDerivative(sand, rock, blendRock);

            return output;
        }

        override float4 Compute()
        {
            float3 triW = abs(streams.meshNormal);
	        triW = triW / (triW.x + triW.y + triW.z);

            float uvScale = 0.25f;

            float3 outputX = float3(0, 0, 0);
            float3 outputY = float3(0, 0, 0);
            float3 outputZ = float3(0, 0, 0);

            if (triW.x > 0.0f) outputX = SampleTerrain(streams.PositionWS.zy * uvScale);
            if (triW.y  > 0.0f) outputY = SampleTerrain(streams.PositionWS.xz * uvScale);
            if (triW.z  > 0.0f) outputZ = SampleTerrain(streams.PositionWS.xy * uvScale);

            float3 output = outputX * triW.x + outputY * triW.y + outputZ * triW.z;

            return float4(output, 1);
        }
    };
}