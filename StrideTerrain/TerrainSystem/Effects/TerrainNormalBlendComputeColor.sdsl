namespace StrideTerrain.TerrainSystem.Effects
{
    shader TerrainNormalBlendComputeColor : ComputeColor, TerrainCommon, NormalStream, PositionStream4, Texturing
    {
        compose ComputeColor Sand;
        compose ComputeColor Rock;
        compose ComputeColor Grass;
        compose ComputeColor Snow;

        float InvLerp(float from, float to, float value){
            return (value - from) / (to - from);
        }

        float BlendHeight(float h, float b) {
            if (streams.TerrainHeight < (h - b)) return 0.0f;
            else if (streams.TerrainHeight > (h + b)) return 1.0f;
            return InvLerp(h - b, h + b, streams.TerrainHeight);
        }

        float BlendSlope(float s, float b) {
            float slope = 1.0f - abs(streams.meshNormal.y);
            if (slope < s - b) return 0.0f;
            else if (slope > s + b) return 1.0f;
            else return InvLerp(s - b, s + b, slope);
        }

        float3 GetNormal(float3 normal)
        {
            normal = (2.0f * normal) - 1.0f;
            normal.z = sqrt(max(0, 1.0f - (normal.x * normal.x + normal.y * normal.y)));
            return normal;
        }

        float3 BlendNormal(float3 from, float3 to, float3 a)
        {
            var middleNormal = NormalUtil.BlendRNM(from, to);

            // This is not correct, but try to have a good 0.5 and linear interpol from this
            // ideally, we should have RNM support a blending based of matBlend
            return a < 0.5 ? lerp(from, middleNormal, a / 0.5) : lerp(middleNormal, to, (a - 0.5) * 2);
        }

        float3 SampleTerrain(float2 uv)
        {
            streams.TexCoord2 = uv;

            float blendRock = BlendSlope(0.1f, 0.1f);
            float blendSnow = BlendHeight(200, 60);
            float blendGrass = BlendHeight(79.0f, 2.0f);

            float3 sand = GetNormal(Sand.Compute());
            float3 grass = GetNormal(Grass.Compute());
            float3 snow = GetNormal(Snow.Compute());
            streams.TexCoord2 = uv * 0.1f;
            float3 rock = GetNormal(Rock.Compute());

            float3 output = BlendNormal(sand, grass, blendGrass);
            output = BlendNormal(output, snow, blendSnow);
            output = BlendNormal(sand, rock, blendRock);

            return output;
        }

        override float4 Compute()
        {
            float tighten = 0.4679f;
            float3 triW = saturate(abs(streams.meshNormal) - tighten);

            float uvScale = 0.25f;

            float3 outputX = float3(0, 0, 0);
            float3 outputY = float3(0, 0, 0);
            float3 outputZ = float3(0, 0, 0);

            if (triW.x > 0.0f) outputX = SampleTerrain(streams.PositionWS.zy * uvScale);
            if (triW.y > 0.0f) outputY = SampleTerrain(streams.PositionWS.xz * uvScale);
            if (triW.z > 0.0f) outputZ = SampleTerrain(streams.PositionWS.xy * uvScale);

            float3 output = outputX * triW.x + outputY * triW.y + outputZ * triW.z;

            return float4(output, 1);
        }
    };
}