namespace StrideTerrain.TerrainSystem.Effects
{
    shader TerrainCommon : Texturing
    {
        stage stream int LodLevel;
        stage stream float TerrainHeight;
        stage stream float TerrainHeight01;

        struct ChunkData
        {
            /*    
    public byte LodLevel;
    public byte North;
    public byte South;
    public byte West;
    public byte East;
    public byte ChunkX;
    public byte ChunkZ;
    public byte Padding0;*/
            int Data0;
            int Data1;
            float Scale;
            float3 Position;
            int2 Uv;
            float3 BoundsCenter;
            float3 BoundsExtent;
        };

        rgroup PerMaterial
        {
            stage Texture2D<float> Heightmap;
            stage Texture2D TerrainNormalMap;
            stage StructuredBuffer<ChunkData> ChunkBuffer;
            stage StructuredBuffer<int> SectorToChunkMapBuffer;
        }

        cbuffer PerMaterial 
        {
            stage uint ChunkSize;
            stage float InvTerrainTextureSize;
            stage float InvTerrainSize;
            stage float MaxHeight;
            stage uint ChunksPerRow;
            stage float InvUnitsPerTexel;
        }

        float GetTerrainHeightAt(float wx, float wz)
        {
            wx = wx * InvUnitsPerTexel;
            wz = wz * InvUnitsPerTexel;

            uint sectorX = min(ChunksPerRow, (uint)floor(wx / ChunkSize));
            uint sectorZ = min(ChunksPerRow, (uint)floor(wz / ChunkSize));
            uint sectorIndex = sectorZ * ChunksPerRow + sectorX;
            uint chunkIndex = max(0, SectorToChunkMapBuffer[sectorIndex]);

            uint lodLevel = ChunkBuffer[chunkIndex].Data0 & 0xFF;
			uint scale = 1 << lodLevel;
            float2 uv = ChunkBuffer[chunkIndex].Uv;

            float positionInChunkX = ((float)wx / scale) % ChunkSize;
            float positionInChunkZ = ((float)wz / scale) % ChunkSize;

            uv.x += positionInChunkX + 0.5f;
            uv.y += positionInChunkZ + 0.5f;

            uv *= InvTerrainTextureSize;

            float height = Heightmap.SampleLevel(LinearSampler, uv, 0).x;

            return height * MaxHeight;
        }

        float3 GetTerrainNormalAt(float wx, float wz)
        {
            wx = wx * InvUnitsPerTexel;
            wz = wz * InvUnitsPerTexel;

            uint sectorX = min(ChunksPerRow, (uint)floor(wx / ChunkSize));
            uint sectorZ = min(ChunksPerRow, (uint)floor(wz / ChunkSize));
            uint sectorIndex = sectorZ * ChunksPerRow + sectorX;
            uint chunkIndex = max(0, SectorToChunkMapBuffer[sectorIndex]);

            uint lodLevel = ChunkBuffer[chunkIndex].Data0 & 0xFF;
			uint scale = 1 << lodLevel;
            float2 uv = ChunkBuffer[chunkIndex].Uv;

            float positionInChunkX = ((float)wx) % ChunkSize;
            float positionInChunkZ = ((float)wz) % ChunkSize;

            uv.x += positionInChunkX + 0.5f;
            uv.y += positionInChunkZ + 0.5f;
            
            uv *= InvTerrainTextureSize;

            return TerrainNormalMap.SampleLevel(LinearSampler, uv, 0).xyz;
        }
    };
}