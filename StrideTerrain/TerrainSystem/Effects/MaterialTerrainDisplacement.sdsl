namespace StrideTerrain.TerrainSystem.Effects
{
    shader MaterialTerrainDisplacement : IMaterialSurface, PositionStream4, NormalStream, TransformationBase, Transformation, ShaderBase, Texturing, TerrainCommon
    {
        stage stream uint VertexId : SV_VERTEXID;

        override void Compute()
        {
            float3 vertexPosition;

            int data0 = ChunkInstanceDataBuffer[streams.InstanceID].Data0;
            int data1 = ChunkInstanceDataBuffer[streams.InstanceID].Data1;
            float scale = ChunkInstanceDataBuffer[streams.InstanceID].Scale;
            float3 worldPosition = ChunkInstanceDataBuffer[streams.InstanceID].Position;
            int2 uv = ChunkInstanceDataBuffer[streams.InstanceID].Uv;

            streams.LodLevel = data0 & 0xFF;

            uint ldN = (data0 >> 8) & 0xFF;
            uint ldS = (data0 >> 16) & 0xFF;
            uint ldW = (data0 >> 24) & 0xFF;
            uint ldE = (data1) & 0xFF;

            uint quadIndex = streams.VertexId / (uint)6;

            uint offsetX = (quadIndex % ChunkSize);
            uint offsetZ = (quadIndex / ChunkSize);

            uint triangleVertex = streams.VertexId % (uint)6;
                
            if (triangleVertex == 0) vertexPosition.xz = float2(1 - (ldN > 0 && offsetZ == 0 && (offsetX % 2 == 0) ? 1.0f : 0.0f), 0 + (ldE > 0 && offsetX == (ChunkSize - 1) && (offsetZ % 2 == 1) ? 1.0f : 0.0f));  // 1, 0
            else if (triangleVertex == 1) vertexPosition.xz = float2(1 + (ldS > 0 && offsetZ == (ChunkSize - 1) && (offsetX % 2 == 0) ? 1.0f : 0.0f), 1 + (ldE > 0 && offsetX == (ChunkSize - 1) && (offsetZ % 2 == 0) ? 1.0f : 0.0f)); // 1, 1
            else if (triangleVertex == 2) vertexPosition.xz = float2(0 + (ldS > 0 && offsetZ == (ChunkSize - 1) && (offsetX % 2 == 1) ? 1.0f : 0.0f), 1 - (ldW > 0 && offsetX == 0 && (offsetZ % 2 == 0) ? 1.0f : 0.0f)); // 0, 0

            else if (triangleVertex == 3) vertexPosition.xz = float2(1 - (ldN > 0 && offsetZ == 0 && (offsetX % 2 == 0) ? 1.0f : 0.0f), 0 + (ldE > 0 && offsetX == (ChunkSize - 1) && (offsetZ % 2 == 1) ? 1.0f : 0.0f)); // 1, 0
            else if (triangleVertex == 4) vertexPosition.xz = float2(0 + (ldS > 0 && offsetZ == (ChunkSize - 1) && (offsetX % 2 == 1) ? 1.0f : 0.0f), 1 - (ldW > 0 && offsetX == 0 && (offsetZ % 2 == 0) ? 1.0f : 0.0f)); // 0, 1
            else if (triangleVertex == 5) vertexPosition.xz = float2(0 - (ldN > 0 && offsetZ == 0 && (offsetX % 2 == 1) ? 1.0f : 0.0f), 0 - (ldW > 0 && offsetX == 0 && (offsetZ % 2 == 1) ? 1.0f : 0.0f)); // 0, 0

            vertexPosition.y = 0;

            vertexPosition.x += (float)offsetX;
            vertexPosition.z += (float)offsetZ;

            uv = uv + int2(vertexPosition.xz);
            streams.TexCoord1 = uv * InvTerrainTextureSize;
            streams.TexCoord3 = vertexPosition.xz / (streams.LodLevel + 1);
            streams.TexCoord2 = (vertexPosition.xz / (float)ChunkSize) / (streams.LodLevel + 1);
            streams.TexCoord2 = uv * InvTerrainTextureSize * 100;

            streams.meshNormal = float3(0, 1, 0);
            streams.meshTangent = float4(0, 0, -1, 1);
           
            streams.Position = float4((vertexPosition * scale) + worldPosition, 1);
            streams.PositionWS = streams.Position;

            streams.TexCoord = streams.PositionWS.xz * InvTerrainSize;
            
            float height = Heightmap.Load(int3(uv.xy, 0), 0).x;
            streams.Position.y = height * MaxHeight;
            
            streams.TerrainHeight01 = height;
            streams.TerrainHeight = streams.Position.y;

            streams.meshNormal = TerrainNormalMap.Load(int3(uv.xy, 0), 0).xyz * 2.0 - 1.0;
        }

        stage override void TransformPosition()
        {
            streams.PositionWS = mul(streams.PositionWS, TerrainWorld);
        }

        //stage override void PSMain()
        //{
        //    base.PSMain();

        //    float3 lodColors[10] = {
        //        float3(0, 1, 0),
        //        float3(1, 0, 0),
        //        float3(0, 0, 1),
        //        float3(1, 1, 0),
        //        float3(1, 0, 1),
        //        float3(0, 1, 1),
        //        float3(0, 0.5f, 1),
        //        float3(0, 1, 0.5f),
        //        float3(0.5f, 1, 0.5f),
        //        float3(1, 0.5f, 0.5f)
        //    };

        //    float3 lodColor = lodColors[streams.LodLevel];

        //    float a = 0.5f;
        //    streams.ColorTarget = float4(streams.ColorTarget.xyz * (1.0f - a)+ lodColor.xyz * a, streams.ColorTarget.w);
        //}
    };
}