namespace StrideTerrain.TerrainSystem.Effects.Material
{
    shader MaterialTerrainDisplacement 
        : IMaterialSurface, PositionStream4, NormalStream, TransformationBase, Transformation, ShaderBase, Texturing, TerrainData, TerrainStreams
    {
        stage stream uint VertexId : SV_VERTEXID;

        rgroup PerMaterial
        {
            stage StructuredBuffer<int> ChunkInstanceData;
        }

        override void Compute()
        {
            float3 vertexPosition;

            int chunkIndex = ChunkInstanceData[streams.InstanceID];

            int data0 = ChunkBuffer[chunkIndex].Data0;
            int data1 = ChunkBuffer[chunkIndex].Data1;
            float scale = ChunkBuffer[chunkIndex].Scale;
            float3 worldPosition = ChunkBuffer[chunkIndex].Position;
            int2 uv = ChunkBuffer[chunkIndex].Uv;

            streams.LodLevel = data0 & 0xFF;

            uint ldN = (data0 >> 8) & 0xFF;
            uint ldS = (data0 >> 16) & 0xFF;
            uint ldW = (data0 >> 24) & 0xFF;
            uint ldE = (data1) & 0xFF;

            uint quadIndex = streams.VertexId / (uint)6;

            uint offsetX = (quadIndex % ChunkSize);
            uint offsetZ = (quadIndex / ChunkSize);

            uint triangleVertex = streams.VertexId % (uint)6;
   
            // Please dont look at this (●'◡'●)
            // Set triangle positions and merge triangle if adjacent to lower lod
            if (triangleVertex == 0) vertexPosition.xz = float2(1 - (ldN > 0 && offsetZ == 0 && (offsetX % 2 == 0) ? 1.0f : 0.0f), 0 + (ldE > 0 && offsetX == (ChunkSize - 1) && (offsetZ % 2 == 1) ? 1.0f : 0.0f));  // 1, 0
            else if (triangleVertex == 1) vertexPosition.xz = float2(1 + (ldS > 0 && offsetZ == (ChunkSize - 1) && (offsetX % 2 == 0) ? 1.0f : 0.0f), 1 + (ldE > 0 && offsetX == (ChunkSize - 1) && (offsetZ % 2 == 0) ? 1.0f : 0.0f)); // 1, 1
            else if (triangleVertex == 2) vertexPosition.xz = float2(0 + (ldS > 0 && offsetZ == (ChunkSize - 1) && (offsetX % 2 == 1) ? 1.0f : 0.0f), 1 - (ldW > 0 && offsetX == 0 && (offsetZ % 2 == 0) ? 1.0f : 0.0f)); // 0, 0

            else if (triangleVertex == 3) vertexPosition.xz = float2(1 - (ldN > 0 && offsetZ == 0 && (offsetX % 2 == 0) ? 1.0f : 0.0f), 0 + (ldE > 0 && offsetX == (ChunkSize - 1) && (offsetZ % 2 == 1) ? 1.0f : 0.0f)); // 1, 0
            else if (triangleVertex == 4) vertexPosition.xz = float2(0 + (ldS > 0 && offsetZ == (ChunkSize - 1) && (offsetX % 2 == 1) ? 1.0f : 0.0f), 1 - (ldW > 0 && offsetX == 0 && (offsetZ % 2 == 0) ? 1.0f : 0.0f)); // 0, 1
            else if (triangleVertex == 5) vertexPosition.xz = float2(0 - (ldN > 0 && offsetZ == 0 && (offsetX % 2 == 1) ? 1.0f : 0.0f), 0 - (ldW > 0 && offsetX == 0 && (offsetZ % 2 == 1) ? 1.0f : 0.0f)); // 0, 0

            vertexPosition.y = 0;

            vertexPosition.x += (float)offsetX;
            vertexPosition.z += (float)offsetZ;

            // Setup some uv's
            uv = uv + int2(vertexPosition.xz);
            streams.TexCoord1 = uv * InvTerrainTextureSize;
            streams.TexCoord3 = vertexPosition.xz / (streams.LodLevel + 1);
            streams.TexCoord2 = uv * InvTerrainTextureSize * 100;

            streams.meshNormal = float3(0, 1, 0);
            streams.meshTangent = float4(0, 0, -1, 1);
           
            streams.Position = float4((vertexPosition * scale) + worldPosition, 1);
            streams.PositionWS = streams.Position;

            streams.TexCoord = streams.PositionWS.xz * InvTerrainSize;
            
            float height = Heightmap.Load(int3(uv.xy, 0), 0).x;
            streams.Position.y = height * MaxHeight;
            
            streams.TerrainHeight01 = height;
            streams.TerrainHeight = streams.Position.y;

            streams.meshNormal = TerrainNormalMap.Load(int3(uv.xy, 0), 0).xyz * 2.0 - 1.0;
        }
    };
}