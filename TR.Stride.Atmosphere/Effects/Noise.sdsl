namespace TR.Stride.Atmosphere
{
    shader Noise
    {
		#define HALF_FLT_MAX 65504.0

		float3 Interpolation_C2(float3 x)
		{
			return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);
		}

		void PerlinHash(float3 gridcell, float s, bool tile,
										out float4 lowz_hash_0,
										out float4 lowz_hash_1,
										out float4 lowz_hash_2,
										out float4 highz_hash_0,
										out float4 highz_hash_1,
										out float4 highz_hash_2)
		{
			const float2 OFFSET = float2(50.0, 161.0);
			const float DOMAIN = 69.0;
			const float3 SOMELARGEFLOATS = float3(635.298681, 682.357502, 668.926525);
			const float3 ZINC = float3(48.500388, 65.294118, 63.934599);

			gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * (1.0 / DOMAIN)) * DOMAIN;
			float d = DOMAIN - 1.5;
			float3 gridcell_inc1 = step(gridcell, float3(d, d, d)) * (gridcell + 1.0);

			gridcell_inc1 = tile ? gridcell_inc1 % s : gridcell_inc1;

			float4 P = float4(gridcell.xy, gridcell_inc1.xy) + OFFSET.xyxy;
			P *= P;
			P = P.xzxz * P.yyww;
			float3 lowz_mod = float3(1.0 / (SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz));
			float3 highz_mod = float3(1.0 / (SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz));
			lowz_hash_0 = frac(P * lowz_mod.xxxx);
			highz_hash_0 = frac(P * highz_mod.xxxx);
			lowz_hash_1 = frac(P * lowz_mod.yyyy);
			highz_hash_1 = frac(P * highz_mod.yyyy);
			lowz_hash_2 = frac(P * lowz_mod.zzzz);
			highz_hash_2 = frac(P * highz_mod.zzzz);
		}

		float Perlin(float3 P, float s, bool tile)
		{
			P *= s;

			float3 Pi = floor(P);
			float3 Pi2 = floor(P);
			float3 Pf = P - Pi;
			float3 Pf_min1 = Pf - 1.0;

			float4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;
			PerlinHash(Pi2, s, tile, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1);

			float4 grad_x0 = hashx0 - 0.49999;
			float4 grad_y0 = hashy0 - 0.49999;
			float4 grad_z0 = hashz0 - 0.49999;
			float4 grad_x1 = hashx1 - 0.49999;
			float4 grad_y1 = hashy1 - 0.49999;
			float4 grad_z1 = hashz1 - 0.49999;
			float4 grad_results_0 = rsqrt(grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0) * (float2(Pf.x, Pf_min1.x).xyxy * grad_x0 + float2(Pf.y, Pf_min1.y).xxyy * grad_y0 + Pf.zzzz * grad_z0);
			float4 grad_results_1 = rsqrt(grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1) * (float2(Pf.x, Pf_min1.x).xyxy * grad_x1 + float2(Pf.y, Pf_min1.y).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1);

			float3 blend = Interpolation_C2(Pf);
			float4 res0 = lerp(grad_results_0, grad_results_1, blend.z);
			float4 blend2 = float4(blend.xy, float2(1.0 - blend.xy));
			float final = dot(res0, blend2.zxzx * blend2.wwyy);
			final *= 1.0 / sqrt(0.75);
			return ((final * 1.5) + 1.0) * 0.5;
		}

		float Remap(float value, float orignalMin, float orignalMax, float newMin, float newMax)
		{
			return newMin + (saturate((value - orignalMin) / (orignalMax - orignalMin)) * (newMax - newMin));
		}

		// https://www.shadertoy.com/view/3dVXDc
        /**
            An implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds
            inspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider
            (Guerrilla Games). The first column is the perlin-worley noise generated by remapping
            perlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms
            with increasing frequencies, and are used to model the cloud shapes which are rendered
            in the last column. See the common tab for all the noise functions used.
        */

        // Hash by David_Hoskins
        float3 hash33(float3 p3)
        {
	        p3 = frac(p3 * float3(.1031, .1030, .0973));
            p3 += dot(p3, p3.yxz+33.33);
            return frac((p3.xxy + p3.yxx)*p3.zyx);
        }

        // Gradient noise by iq (modified to be tileable)
        float GradientNoise(float3 x, float freq)
        {
            // grid
            float3 p = floor(x);
            float3 w = frac(x);
    
            // quintic interpolant
            float3 u = w * w * w * (w * (w * 6. - 15.) + 10.);
    
            // gradients
            float3 ga = hash33(fmod(p + float3(0., 0., 0.), freq));
            float3 gb = hash33(fmod(p + float3(1., 0., 0.), freq));
            float3 gc = hash33(fmod(p + float3(0., 1., 0.), freq));
            float3 gd = hash33(fmod(p + float3(1., 1., 0.), freq));
            float3 ge = hash33(fmod(p + float3(0., 0., 1.), freq));
            float3 gf = hash33(fmod(p + float3(1., 0., 1.), freq));
            float3 gg = hash33(fmod(p + float3(0., 1., 1.), freq));
            float3 gh = hash33(fmod(p + float3(1., 1., 1.), freq));
    
            // projections
            float va = dot(ga, w - float3(0., 0., 0.));
            float vb = dot(gb, w - float3(1., 0., 0.));
            float vc = dot(gc, w - float3(0., 1., 0.));
            float vd = dot(gd, w - float3(1., 1., 0.));
            float ve = dot(ge, w - float3(0., 0., 1.));
            float vf = dot(gf, w - float3(1., 0., 1.));
            float vg = dot(gg, w - float3(0., 1., 1.));
            float vh = dot(gh, w - float3(1., 1., 1.));
	
            // interpolation
            return va + 
                   u.x * (vb - va) + 
                   u.y * (vc - va) + 
                   u.z * (ve - va) + 
                   u.x * u.y * (va - vb - vc + vd) + 
                   u.y * u.z * (va - vc - ve + vg) + 
                   u.z * u.x * (va - vb - ve + vf) + 
                   u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);
        }

        // Tileable 3D worley noise
        float WorleyNoise(float3 uv, float freq)
        {    
            float3 id = floor(uv);
            float3 p = frac(uv);
    
            float minDist = 10000.;
            for (float x = -1.; x <= 1.; ++x)
            {
                for(float y = -1.; y <= 1.; ++y)
                {
                    for(float z = -1.; z <= 1.; ++z)
                    {
                        float3 offset = float3(x, y, z);
            	        float3 h = hash33(fmod(id + offset, freq.xxx)) * .5 + .5;
    			        h += offset;
            	        float3 d = p - h;
           		        minDist = min(minDist, dot(d, d));
                    }
                }
            }
    
            // inverted worley noise
            return 1. - minDist;
        }

        // Fbm for Perlin noise based on iq's blog
        float PerlinFbm(float3 p, float freq, int octaves)
        {
            float G = exp2(-.85);
            float amp = 1.;
            float noise = 0.;
            for (int i = 0; i < octaves; ++i)
            {
                noise += amp * GradientNoise(p * freq, freq);
                freq *= 2.;
                amp *= G;
            }
    
            return noise;
        }

        // Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes
        // chapter in GPU Pro 7.
        float WorleyFbm(float3 p, float freq)
        {
            return WorleyNoise(p*freq, freq) * .625 +
                   WorleyNoise(p*freq*2., freq*2.) * .25 +
                   WorleyNoise(p*freq*4., freq*4.) * .125;
        }
    };
}